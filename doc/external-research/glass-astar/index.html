<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>Coke and Code</title>
<style type="text/css" title="currentStyle">@import "style.css";</style> 
<link type="text/css" rel="stylesheet" href="index_files/widget.css"><style type="text/css">#twtr-widget-1 .twtr-avatar { display: none; } #twtr-widget-1 .twtr-tweet-text { margin-left: 0; }</style><style type="text/css">#twtr-widget-1 .twtr-doc,                      #twtr-widget-1 .twtr-hd a,                      #twtr-widget-1 h3,                      #twtr-widget-1 h4 {            background-color: #333333 !important;            color: #ffffff !important;          }          #twtr-widget-1 .twtr-tweet a {            color: #d1bd4a !important;          }          #twtr-widget-1 .twtr-bd, #twtr-widget-1 .twtr-timeline i a,           #twtr-widget-1 .twtr-bd p {            color: #ffffff !important;          }          #twtr-widget-1 .twtr-new-results,           #twtr-widget-1 .twtr-results-inner,           #twtr-widget-1 .twtr-timeline {            background: #000000 !important;          }</style></head>

<body>

<div id="container">

<div id="topbar">
</div>

<a id="topleft" href="http://www.cokeandcode.com/index.html" title="Home"></a>

<div id="links">
<a href="http://www.cokeandcode.com/index.html?page=games">GAMES</a>
<a href="http://www.cokeandcode.com/index.html?page=blog">BLOG</a>
<a href="http://www.cokeandcode.com/index.html?page=tutorials">TUTORIALS</a>
<a href="http://www.cokeandcode.com/index.html?page=libs">LIBRARIES</a>
<a href="http://www.legendsofyore.com/forum">FORUMS</a>
<a href="http://www.cokeandcode.com/index.html?page=contact">CONTACT</a>
<a href="http://www.cokeandcode.com/index.html?page=about">ABOUT</a>
</div>

<div id="twitter">
<script src="index_files/widget.js"></script>
<script>
new TWTR.Widget({
  version: 2,
  type: 'profile',
  rpp: 4,
  interval: 6000,
  width: 'auto',
  height: 300,
  theme: {
    shell: {
      background: '#333333',
      color: '#ffffff'
    },
    tweets: {
      background: '#000000',
      color: '#ffffff',
      links: '#d1bd4a'
    }
  },
  features: {
    scrollbar: false,
    loop: false,
    live: false,
    hashtags: true,
    timestamp: true,
    avatars: false,
    behavior: 'all'
  }
}).render().setUser('cokeandcode').start();
</script><div class="twtr-widget twtr-widget-profile" id="twtr-widget-1"><div class="twtr-doc" style="width: 100%;">            <div class="twtr-hd"><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode" class="twtr-profile-img-anchor"><img alt="profile" class="twtr-profile-img" src="index_files/streetfighteriiturbo21_4_normal.gif"></a>                      <h3>Kevin Glass</h3>                      <h4><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode">cokeandcode</a></h4>             </div>            <div class="twtr-bd">              <div class="twtr-timeline" style="height: auto;">                <div class="twtr-tweets">                  <div class="twtr-reference-tweet"></div><div class="twtr-tweet" id="tweet-id-4"><div class="twtr-tweet-wrap">         <div class="twtr-avatar">           <div class="twtr-img"><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode"><img alt="cokeandcode profile" src="index_files/streetfighteriiturbo21_4_normal.gif"></a></div>         </div>         <div class="twtr-tweet-text">           <p>             <a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode" class="twtr-user">cokeandcode</a> And the iPad hacking goes on <a href="http://twitter.com/search?q=%23dayjob" title="#dayjob" class="tweet-url hashtag" target="_blank">#dayjob</a>             <em>            <a target="_blank" class="twtr-timestamp" time="Mon Nov 28 17:12:10 +0000 2011" href="http://twitter.com/cokeandcode/status/141202734689959936">6 minutes ago</a>             <a target="_blank" class="twtr-reply" href="http://twitter.com/intent/tweet?in_reply_to=141202734689959936">reply</a>              <a target="_blank" class="twtr-rt" href="http://twitter.com/intent/retweet?tweet_id=141202734689959936">retweet</a>              <a target="_blank" class="twtr-fav" href="http://twitter.com/intent/favorite?tweet_id=141202734689959936">favorite</a>             </em>           </p>         </div>       </div></div><div class="twtr-tweet" id="tweet-id-3"><div class="twtr-tweet-wrap">         <div class="twtr-avatar">           <div class="twtr-img"><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode"><img alt="cokeandcode profile" src="index_files/streetfighteriiturbo21_4_normal.gif"></a></div>         </div>         <div class="twtr-tweet-text">           <p>             <a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode" class="twtr-user">cokeandcode</a> <a class="tweet-url username" data-screen-name="Rockenez" href="http://twitter.com/Rockenez" target="_blank">@Rockenez</a> Cheers             <em>            <a target="_blank" class="twtr-timestamp" time="Mon Nov 28 16:17:54 +0000 2011" href="http://twitter.com/cokeandcode/status/141189078413606912">about 1 hour ago</a>             <a target="_blank" class="twtr-reply" href="http://twitter.com/intent/tweet?in_reply_to=141189078413606912">reply</a>              <a target="_blank" class="twtr-rt" href="http://twitter.com/intent/retweet?tweet_id=141189078413606912">retweet</a>              <a target="_blank" class="twtr-fav" href="http://twitter.com/intent/favorite?tweet_id=141189078413606912">favorite</a>             </em>           </p>         </div>       </div></div><div class="twtr-tweet" id="tweet-id-2"><div class="twtr-tweet-wrap">         <div class="twtr-avatar">           <div class="twtr-img"><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode"><img alt="cokeandcode profile" src="index_files/streetfighteriiturbo21_4_normal.gif"></a></div>         </div>         <div class="twtr-tweet-text">           <p>             <a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode" class="twtr-user">cokeandcode</a> <a class="tweet-url username" data-screen-name="zibidybingbong" href="http://twitter.com/zibidybingbong" target="_blank">@zibidybingbong</a> I actually live up in Caerphilly, bought my car down there. I'm not actually Welsh, I'm afraid I'm English ;)             <em>            <a target="_blank" class="twtr-timestamp" time="Mon Nov 28 16:17:37 +0000 2011" href="http://twitter.com/cokeandcode/status/141189010470080512">about 1 hour ago</a>             <a target="_blank" class="twtr-reply" href="http://twitter.com/intent/tweet?in_reply_to=141189010470080512">reply</a>              <a target="_blank" class="twtr-rt" href="http://twitter.com/intent/retweet?tweet_id=141189010470080512">retweet</a>              <a target="_blank" class="twtr-fav" href="http://twitter.com/intent/favorite?tweet_id=141189010470080512">favorite</a>             </em>           </p>         </div>       </div></div><div class="twtr-tweet" id="tweet-id-1"><div class="twtr-tweet-wrap">         <div class="twtr-avatar">           <div class="twtr-img"><a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode"><img alt="cokeandcode profile" src="index_files/streetfighteriiturbo21_4_normal.gif"></a></div>         </div>         <div class="twtr-tweet-text">           <p>             <a target="_blank" href="http://twitter.com/intent/user?screen_name=cokeandcode" class="twtr-user">cokeandcode</a> <a class="tweet-url username" data-screen-name="zibidybingbong" href="http://twitter.com/zibidybingbong" target="_blank">@zibidybingbong</a> So you're a cardiff lad? Been trying to find indies in the area -  I figure there must be loads?             <em>            <a target="_blank" class="twtr-timestamp" time="Mon Nov 28 16:16:25 +0000 2011" href="http://twitter.com/cokeandcode/status/141188707620356096">about 1 hour ago</a>             <a target="_blank" class="twtr-reply" href="http://twitter.com/intent/tweet?in_reply_to=141188707620356096">reply</a>              <a target="_blank" class="twtr-rt" href="http://twitter.com/intent/retweet?tweet_id=141188707620356096">retweet</a>              <a target="_blank" class="twtr-fav" href="http://twitter.com/intent/favorite?tweet_id=141188707620356096">favorite</a>             </em>           </p>         </div>       </div></div>                  <!-- tweets show here -->                </div>              </div>            </div>            <div class="twtr-ft">              <div><a target="_blank" href="http://twitter.com/"><img alt="" src="index_files/widget-logo.png"></a>                <span><a target="_blank" class="twtr-join-conv" style="color: rgb(255, 255, 255);" href="http://twitter.com/cokeandcode">Join the conversation</a></span>              </div>            </div>          </div></div>
</div>


<div id="content-container">
<div id="content">
	<h1>Path Finding on Tile based Maps</h1> 
<h2>Introduction</h2> 
<p>Path Finding is something that seems difficult at first thought. How 
do I work out the best way for one of the guys in my game to get from 
one location to another taking account of other things on the map. In 
the general case this is a pretty difficult problem, if you consider 
free form maps and accounting for other things wandering around the map 
at the same time it really gets very complicated.</p> 
<p>This tutorial hopes to provide somewhere to start, explaining the 
most common path finding algorithm in the more simple case of tile based
 maps. It'll cover how the algorithm works and provide some reusable 
code to find paths across arbitrary tile based maps.</p> 
<p>The full package for this tutorial can be downloaded <a href="http://www.cokeandcode.com/pathfinder/PathFindingTutorial/pathfinding.zip">here</a>. The example provided can be tried via <a href="http://www.cokeandcode.com/pathfinder/PathFindingTutorial/target/pathfinder.jnlp">Java Web Start here</a>.</p> 
<p>The code for the tutorial is here:</p> 
<p><b>Reusable Path Finding Code</b></p> 
<p><a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/PathFinder.java">PathFinder.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/AStarPathFinder.java">AStarPathFinder.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/AStarHeuristic.java">AStarHeuristic.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/Path.java">Mover.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/Path.java">Path.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/TileBasedMap.java">TileBasedMap.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/heuristics/ClosestHeuristic.java">ClosestHeuristic.java</a></p> 
<p><b>Example Game Prototype</b></p> 
<p><a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/PathTest.java">PathTest.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/GameMap.java">GameMap.java</a><br> 
<a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/UnitMover.java">UnitMover.java</a></p> 
<p><i>Disclaimer: This tutorial is provided as is. I don't guarantee 
that the provided source is perfect or that that it provides best 
practices.</i></p> 
<h2>The A* Algorithm</h2> 
<p>The A Star (A*) algorithm is probably one of the most commonly used 
in games programming. The reason is that, as we will see, it's extremely
 configurable to the particular type of game and map. It can be tuned to
 provide good performance against most data sets.</p> 
<p>A* works by maintaining a pair of lists, one containing locations on 
the tile map which may be a next step in the path (called the 'open' 
list) and one containing locations that have already been searched 
(called the 'closed' list). The algorithm keeps looping while there are 
still next steps to be considered. It chooses the most likely of the 
next steps available and considers it's neighbors. Each neighbor gets 
added a potential next step and we continue looping. As each location is
 considered as a step it's removed from the open list and added to the 
closed list (i.e. the list of locations that have been searched). In 
this way we search the map for possible locations but tend towards 
choosing the "most likely" steps first - this is why the algorithm is 
reasonably efficient. </p> 
<p>However, how do we determine which next step is "most likely"? Thats 
where the configuration of the algorithm comes in. Each time we need to 
choose the most likely next step we resolve each possible step against a
 "heuristic". This is just a formal name for a function that provides a 
priority value for anything (more on these later). </p> 
<p>There are two primary values used in A*. The first, already 
mentioned, is the "heuristic cost". This cost determines which step is 
most likely. The second value we use to choose the best next step is the
 cost of getting to the current location, i.e. how many steps is the 
currently location away from starting point - this is called the "path 
cost". By combining these two values the algorithm considers both the 
most likely route and the shortest.</p> 
<p>Let's look at the algorithm in more detail and in a more implementation oriented manner.</p> 
<h3>Pseudo Code</h3> 
<p>The A* algorithm works like this:</p><ol><li>At initialization add the starting location to the open list and empty the closed list</li><li>While there are still more possible next steps in the open list and we haven't found the target:<ol><li>Select the most likely next step (based on both the heuristic and path costs)</li><li>Remove it from the open list and add it to the closed</li><li>Consider each neighbor of the step. For each neighbor:<ol><li>Calculate the path cost of reaching the neighbor</li><li>If
 the cost is less than the cost known for this location then remove it 
from the open or closed lists (since we've now found a better route)</li><li>If
 the location isn't in either the open or closed list then record the 
costs for the location and add it to the open list (this means it'll be 
considered in the next search). Record how we got to this location</li></ol></li></ol></li></ol>The
 loop ends when we either find a route to the destination or we run out 
of steps. If a route is found we back track up the records of how we 
reached each location to determine the path.<p></p> 
<h3>Heuristics - how to determine what's a good next step?</h3> 
<p>As mentioned already, the A* algorithm depends on evaluating the best
 next step in searching for a path. This is done by evaluating each of 
the possible next steps against a heuristic to give a value that can be 
used to sort the list and hence determine the most likely next step. As 
you can imagine this makes choosing a good heuristic for your map and 
game really important to getting good path finding performance. </p> 
<p>In the example code we'll make the heuristic "pluggable", i.e. it'll 
be possible to provide a class to implement a new heuristic. Let's first
 look at a couple of commonly used heuristics.</p> 
<h4>Euclidean Distance</h4> 
<p>The most obvious way to determine the best step is to always pick the
 step that is the closest to the target. This isn't always perfect for 
environments with a lot of obstacles or that are maze like but it does 
provide a simple heuristic to understand. It would look like:<br> 
<code></code></p><code> 
<pre> 
    dx = targetX - currentX;
    dy = targetY - currentY;
    heuristic = sqrt((dx*dx)+(dy*dy));
</pre></code><p><code></code></p> 
<p>Remembering that the heuristic is evaluated frequently during the 
path finding process we can see that this may not always be a good idea.
 That sqrt() call is (on most hardware) expensive.</p> 
<h4>Manhattan Distance</h4> 
<p>Another common approach is to replace absolute distance with 
"Manhattan Distance". This is an approximation of the distance between 
two points based on adding the horizontal distance and vertical 
distances rather than computing the exact difference. That would look 
like this:<br> 
<code></code></p><code> 
<pre> 
    dx = abs(targetX - currentX);
    dy = abs(targetY - currentY);
    heuristic = dx+dy;
</pre></code><p><code></code><br> 
This might not always work that well (especially if you allow diagonal 
movement) but it will work in some limited circumstances and is much 
cheaper. This is a good example of how the A* algorithm can be 
customized for specific games and maps.</p> 
<h2>Tutorial Wars - The Example</h2> 
<p></p><center><img src="index_files/path1.png"></center><p></p> 
<p>To demonstrate A* we're going to build the beginnings of a game in 
which you can move units around on a game map. Different units will be 
able to move through different terrains and obstacles. The code will 
show a path from the selected unit to a destination before allowing us 
to actually move the unit itself.</p> 
<h2>Writing a reusable Path Finder</h2> 
<p>The tutorial code used here is going to get committed into the <a href="http://slick.cokeandcode.com/">Slick</a>
 library as a utility, so ideally it should be nice and reusable. With 
this in mind we're going to build the code in such a way that different 
games can plug into it with the minimal of fuss.</p> 
<p>In addition we need to make sure the heuristic can be changed for 
different games and that it's not too tricky to write a new heuristic 
specific to a given game. In the next couple of sections we'll look at 
the most important part of developing reusable code, the software 
contract.</p> 
<h3>What the Path Finder requires from the Developer?</h3> 
<p>The path finder code needs to be able to understand the game's 
concept of a map. We're taking the bold assumption that the game is 2D 
and grid based - though this covers a lot of different games. Looking at
 the algorithm, what does the path finder need to know about the game 
map:</p><ul><li>Whether a given tile is blocked or not - potentially based on a given moving entity</li><li>The cost of moving from one location to an adjacent location</li></ul>To
 make the map data usable we're also going to need to know the extent of
 the map, i.e. it's width and height. From these requirements we can 
extract this contract (interface: <a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/TileBasedMap.java">TileBasedMap.java</a>):<br> 
<code><p></p> 
<pre> 
public interface TileBasedMap {
    public int getWidthInTiles();
    public int getHeightInTiles();	
    public boolean blocked(Mover mover, int x, int y);	
    public float getCost(Mover mover, int sx, int sy, int tx, int ty);
    public void pathFinderVisited(int x, int y);
}
</pre></code><p><code></code><br> 
There's one extra method in there we haven't talked about, 
pathFinderVisited. This is going to allow the path finder to let us know
 that it's searched a particular location. We'll e able to see how much 
of the map had to be searched before finding a path, this will hopefully
 help us debug and build efficient heuristics.</p> 
<p>There's also a second concept in the interface, the "Mover". In most 
games the thing that's actually going to move has properties that 
control where or what it can do - in our example for instance the boat 
can only move on water. If you look at the <a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/Mover.java">Mover.java</a>
 interface you may be slightly surprised: It contains no methods at all!
 This type of interface is called a tagging or marker interface and just
 allows us to give context and typing to otherwise undefined entities. 
Essentially this means the Mover can be any object that the game knows 
about. As the object passes out of the game domain and into the reusable
 code domain it becomes an unknown object - an opaque Mover. When it 
re-enters the game domain (as it's passed into the TileBasedMap) the 
game implementation is safe to cast it back to whatever it passed in and
 make determinations based on it. There are slightly neater ways to do 
this using generics but it's thats out of scope here.</p> 
<p>What the Mover interface gives us is the ability to make cost and 
blockage decisions based on the entity moving. A hero can't walk through
 walls - but maybe a ghost can. The Mover interface lets us make this 
distinction in the middle of our path finding algorithm.</p> 
<p>Now we've seen what the game must provide, lets consider what path finding code gives us.</p> 
<h3>How does the Developer use the Path Finder?</h3> 
<p>First we need to consider how the developer will invoke the path 
finder. They'll definitely have to provide a starting and ending point 
for the path each time. As mentioned above we'll also have to provide 
the description of the game entity doing the moving. Finally, the whole 
point, we'll want a path back from the invocation that describes the 
route from start to finish:<br> 
<code></code></p><code> 
<pre> 
public interface PathFinder {
	public Path findPath(Mover mover, int sx, int sy, int tx, int ty);
}
</pre></code><p><code></code><br> 
There's one thing missing, how does the path finder know what tile based
 map to be searching? In this case thats down to the implementation 
(which we'll see in a moment). Storing the map being searched in the 
PathFinder implementation has it's benefits - information about the map 
can be cached within the finder. However, this also means that the same 
path finder instance can't be reused over and over for different maps.</p> 
<p>We've seen the Mover interface before, what about the Path object 
that gets returned. It contains just enough information to describe the 
route:<br> 
<code></code></p><code> 
<pre> 
public class Path {
	public int getLength();
	public Step getStep(int index);	
	public int getX(int index);
	public int getY(int index);
	public void appendStep(int x, int y);
	public void prependStep(int x, int y);
	public boolean contains(int x, int y);
}
</pre></code><p><code></code><br> 
The path is essentially a list (in fact it's implemented with an 
ArrayList) of Step objects, where a "Step" represents a single location 
on the path. The methods should be self explanatory, we can simply add 
things to the path and then interrogate the list of steps when using it 
in the game.</p> 
<p>We've now completed the contract between the game and the path 
finding code, yet we still can't actually do anything. We could write 
our game against this interface and check everything fits together 
nicely before implementing the A* algorithm. However, since thats the 
thing the tutorial is meant to be about we'll look at it first.</p> 
<h2>The A* Implementation</h2> 
<p>The A* algorithm as described above fits nicely into the contract 
we've defined. The PathFinder implementation of A* can be found in <a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/AStarPathFinder.java">AStarPathFinder.java</a>.
 We'll look at the algorithm implementation in detail next, but first 
let's consider how the algorithm elements have translated into the code.</p> 
<p>The open and closed lists as described in the algorithm have become lists in our class:<br> 
<code><br> 
/** The set of nodes that have been searched through */<br> 
private ArrayList closed = new ArrayList ();<br> 
/** The set of nodes that we do not yet consider fully searched */<br> 
private SortedList open = new SortedList ();<br> 
</code><br> 
Notice how the open set is "sorted" meaning that our most likely next 
step can be sorted to the top of the set for selection. Next we have the
 map of data that is being searched:<br> 
<code><br> 
/** The map being searched */<br> 
private TileBasedMap map;<br> 
</code><br> 
..which is passed in at construction of the path finder. This allows us 
to cache this next bit, we need to store information about every cell in
 the tiled map:<br> 
<code><br> 
/** The complete set of nodes across the map */<br> 
private Node[][] nodes;<br> 
</code><br> 
So we've created a small inner class called "Node" which will hold 
information about particular locations on the map. This is quite an 
overhead but makes the code easy to read. It could be more optimal to 
store the information in primitive arrays, but lets not worry about that
 here. Finally we have the all important heuristic that drives the A*:<br> 
<code><br> 
/** The heuristic we're applying to determine which nodes to search first */<br> 
private AStarHeuristic heuristic;<br> 
</code><br> 
This is yet another interface, <a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/slick/util/pathfinding/AStarHeuristic.java">AStarHeuristic.java</a>
 which we also (optionally) pass in at construction. This allows us to 
build custom heuristics for path finding. The heuristic interface has a 
single method:<br> 
<code><br> 
public float getCost(TileBasedMap map, Mover mover, int x, int y, int tx, int ty);<br> 
</code><br> 
Each time we need to determine the priority of a particular location 
we'll call this method, supplying the location we're considering and 
where we're trying to get to eventually. This should make writing new 
heuristics simple and nicely separate.</p> 
<p>Now we know whats available to us, lets look at the A* 
implementation. Most of the work is done in the findPath() method which 
we'll cover in detail in the next few sections.</p> 
<h3>Initialization</h3> 
<p>The initialization of the algorithm looks like this:<br> 
<code></code></p><code> 
<pre> 
if (map.blocked(mover, tx, ty)) {
	return null;
}
		
// initial state for A*. The closed group is empty. Only the starting
// tile is in the open list and it's cost is zero, i.e. we're already there
nodes[sx][sy].cost = 0;
nodes[sx][sy].depth = 0;
closed.clear();
open.clear();
open.add(nodes[sx][sy]);
 
// set the parent of the target location to null to mark that 
// we haven't found a route yet
nodes[tx][ty].parent = null;
</pre></code><p><code></code></p> 
<p>The first check we perform is an simple optimization. If the target 
we're attempting to find a route to is blocked then there is no way we 
can find a route there. Returning null indicates there's no path that 
can be found.</p> 
<p>Next we initialize the information on the starting location and add 
it to the open list, ready to start searching. We're at initial state, 
the open set has one element and the closed set is empty.</p> 
<h3>Searching the Map</h3> 
<p>This is the big bit, following along with the algorithm we need to 
loop choosing the best available step moving closer to the target and an
 appropriate path. Let's look at the code:</p> 
<p><code></code></p><code> 
<pre> 
int maxDepth = 0;
while ((open.size() != 0)) &amp;&amp; (maxDepth &lt; maxSearchDistance)) {
</pre></code><p><code></code></p> 
<p>So, were going to loop while there are still available steps and 
while the best next step isn't the target - i.e. until we've found the 
path or haven't got anywhere else to search. The extra piece here is a 
safe guard that most games will want, the search can't go on forever - 
we need to limit it. In this case we only allow the path search to get 
to certain number of steps in length before we give up.</p> 
<p>Next we need to take the best step, mark is as searched and then consider it's neighbors:<br> 
<code></code></p><code> 
<pre>	
Node current = getFirstInOpen();
if (current == nodes[tx][ty]) {
     break;
}
removeFromOpen(current);
addToClosed(current);
			
for (int x=-1;x&lt;2;x++) {
	for (int y=-1;y&lt;2;y++) {
		if ((x == 0) &amp;&amp; (y == 0)) {
			continue;
		}
					
		int xp = x + current.x;
		int yp = y + current.y;
					
		if (isValidLocation(mover,sx,sy,xp,yp)) {	
			int nextStepCost = current.cost + 
                                           getMovementCost(mover, current.x, 
                                                           current.y, xp, yp);
			Node neighbour = nodes[xp][yp];
			map.pathFinderVisited(xp, yp);
</pre></code><p><code></code>						</p> 
<p>We grab the best next step (getFirstInOpen()) and consider this our 
"current" location. If the current location is the target, then end the 
search we've found our route! Removing the current location from the 
open list and adding it to the closed list marks it as searched. We then
 cycle through all of it's neighbors (excluding the [0,0] current 
location) considering their cost. Note that the path cost to the 
neighbor is calculated based on the cost to get the current node added 
to the movement cost associated with moving from current location to the
 neighbor.</p> 
<p>For each of the neighbors we've found we need to consider two things.
 First, have we found a shorter path to this location than previously, 
if so we need to re-search it. Second, if we don't already have this as a
 step to consider we need to record it so it may get chosen as the next 
step and hence get us closer to the target:</p> 
<p><code></code></p><code> 
<pre> 
	if (nextStepCost &lt; neighbour.cost) {
		if (inOpenList(neighbour)) {
			removeFromOpen(neighbour);
		}
		if (inClosedList(neighbour)) {
			removeFromClosed(neighbour);
		}
	}
			
	if (!inOpenList(neighbour) &amp;&amp; !(inClosedList(neighbour))) {
		neighbour.cost = nextStepCost;
		maxDepth = Math.max(maxDepth, neighbour.setParent(current));
		neighbour.heuristic = getHeuristicCost(mover, xp, yp, tx, ty);
		open.add(neighbour);
	}
</pre></code><p><code></code></p> 
<p>This first condition up there is checking that we haven't found a 
better route to a node we'd previously considered searched (i.e. it's in
 the open or closed lists). If we've found a better route to the node 
(the cost is less than the recorded cost) then remove it from the lists 
it's stored in to mark as un-searched.</p> 
<p>Finally we consider the neighbor in the context of whether its a good
 next step. If we haven't already searched it (or we've made it 
available again because we've found a better path) then we need to 
record the costs associated with it and make it a possible next step 
(add it to the open list). Note that we call setParent() on the node to 
record how we got to this new node. This information will be used later 
when we're determining the route we used to reached the target node and 
hence building the Path object to return.</p> 
<h3>Building the Path</h3> 
<p>Our final step once we've finished looping is to build a path object 
(if we found a path) and return it to the developer. That looks like 
this:<br> 
<code></code></p><code> 
<pre> 
// since we've got an empty open list or we've run out of search 
// there was no path. Just return null
if (nodes[tx][ty].parent == null) {
	return null;
}
		
// At this point we've definitely found a path so we can uses the parent
// references of the nodes to find out way from the target location back
// to the start recording the nodes on the way.
Path path = new Path();
Node target = nodes[tx][ty];
while (target != nodes[sx][sy]) {
	path.prependStep(target.x, target.y);
	target = target.parent;
}
path.prependStep(sx,sy);
	
// thats it, we have our path 
return path;
</pre></code><p><code></code></p> 
<p>First, if we haven't found a route to the target we just return null 
to indicate that there was no path. If we did find a path we cycle 
through the information we've recorded stepping up through the parent's 
of the path to build up the route we've discovered. Pass it back to the 
user and we're done!</p> 
<p>Now we've seen how to find the paths, let's quickly cover a simple example of using it.</p> 
<h2>The Example Game Source</h2> 
<p>The test case is built up of 3 classes. Most of the code is about 
rendering and handling mouse input which has been covered in other 
tutorials, so won't be covered in depth here. There are 3 classes:</p> 
<p><a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/PathTest.java">PathTest.java</a>
 - This is the main renderer, it draws a tile image for each location in
 the game map. It's also responsible for translating mouse movement and 
clicks into path finding operations.</p> 
<p><a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/GameMap.java">GameMap.java</a>
 - This is the game's implementation of TileBasedMap, it provides the 
description of each location in the game. Each location can hold up to 
two items of information, the type of terrain and optionally an 
indicator as to the type of unit. The interesting bit of code in terms 
of path finding is the blocked() method:<br> 
<code></code></p><code> 
<pre> 
public boolean blocked(Mover mover, int x, int y) {
	// if theres a unit at the location, then it's blocked
	if (getUnit(x,y) != 0) {
		return true;
	}
		
	int unit = ((UnitMover) mover).getType();
	
	// planes can move anywhere
	if (unit == PLANE) {
		return false;
	}
	// tanks can only move across grass
	if (unit == TANK) {
		return terrain[x][y] != GRASS;
	}
	// boats can only move across water
	if (unit == BOAT) {
		return terrain[x][y] != WATER;
	}
	
	// unknown unit so everything blocks
	return true;
}
</pre></code><p><code></code></p> 
<p>So the implementation changes the valid locations based on the unit 
that is moving. It knows which unit is moving by looking at the Mover 
implementation passed in - which we'll see next. In this case tanks are 
limited to ground movement, boats are limited to water movement and 
planes can move anywhere.</p> 
<p><a href="http://www.cokeandcode.com/info/showsrc/showsrc.php?src=../../pathfinder/PathFindingTutorial/target/src/org/newdawn/pathexample/UnitMover.java">UnitMover.java</a>
 - Our mover implementation, it simply holds an integer indicating which
 type of unit is moving. In a full game implementation the mover 
interface may be implemented by the actual objects that represent game 
entities. However, for our purposes a simple integer is enough.</p> 
<p>So, the PathTest class is responsible for rendering the map and 
accepting clicks. When the mouse moves it calls on a path finder to 
determine a path to the location the mouse is over. The path finder 
calls back on the GameMap it's been given using the UnitMover as the 
context in which the path is being found. With luck it finds a path, 
which it describes and passes back to the PathTest class. This path is 
then recorded and rendered next time the screen is updated.</p> 
<p>It's all a little more complete than that, but it's left to the 
reader to fiddle with the example code to understand the details.</p> 
<h2>Conclusion</h2> 
<p>A* is a powerful and useful tool in game development. It's really not
 that complicated once you get going and it can be customized for 
optimal performance in different circumstances. It does get more 
complicated once you start considering other moving entities blocking 
the movement and the 3rd dimension, however hopefully this tutorial has 
given you a simple introduction that can be extended.</p> 
<p>If you notice something that's wrong or could be better a different way please let me know at the address below.</p> 
<h2>Suggested Extensions</h2> 
<p><b>Consider some more Heuristics</b> - Search around the web, lots of people have implemented A* with different heuristics. Try some of them out.<br> 
<b>Optimize the code</b> - The code presented here is trying to be as simple as possible to aid understanding. Optimization options are plentiful. </p> 
<h2>Credits and References</h2> 
<p>Written By: <a href="mailto:tutorials@cokeandcode.com">Kevin Glass&gt;<br> 
Graphics from </a><a href="http://www.advancewarsnet.com/">Advance Wars Net</a></p> 
	<br>
	<br>
	<br>
</div>
</div>

<div id="bottombar">
<a href="http://old.cokeandcode.com/">OLD SITE</a>
</div>

</div>


</body></html>